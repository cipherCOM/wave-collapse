{"version":3,"sources":["../src/wave-collapse.ts","../src/prio-list.ts"],"sourcesContent":["import { ListNode, PrioList } from './prio-list'\n\ntype CellCoords = {\n  x: number\n  y: number\n}\n\ntype Direction = 'Up' | 'Right' | 'Down' | 'Left'\n\ntype StartPosition =\n  | 'random'\n  | 'middle'\n  | 'topLeft'\n  | 'topRight'\n  | 'bottomLeft'\n  | 'bottomRight'\n  | 'defined'\n\ntype StartCell = {\n  /** The starting position of the first collapsed cell. */\n  cell: StartPosition\n  /** The coordinates of the starting cell, only used if 'defined' is selected. */\n  cellCoords?: CellCoords\n  /** The used tile index of the starting cell. */\n  tileIndex: number\n}\n\ntype Options = {\n  /** The base weight value, if the property is omitted on the tile. Default is 10. */\n  defaultTileWeight?: number\n  /** The starting cell configuration. Default is 'random'. */\n  startCell?: StartCell\n  /** The maximum number of retries before the generation is considered failed. Default is 100. */\n  maxRetryCount?: number\n}\n\ntype Exceptions = {\n  /** Exceptions for the left edge. */\n  left?: string[]\n  /** Exceptions for the right edge. */\n  right?: string[]\n  /** Exceptions for the bottom edge. */\n  down?: string[]\n  /** Exceptions for the top edge. */\n  up?: string[]\n}\n\ntype TileDefinition = {\n  /**\n   * The compatibility edges of the tile. Only matching edges can be placed next to each other.\n   *\n   * A good notation is e.g. 'ABC' or 'AAA' describing how the edge \"looks like\". The order is \"top\", \"right\", \"bottom\", \"left\".\n   *\n   * Mind that when describing the edges when looking at a visual tileset top and bottomedges are written from left to right and left and right edges from top to bottom. */\n  edges: [string, string, string, string]\n  /** A custom type given by the user of the tile (e.g., 'floor', 'wall'). This is used to define exceptions for the tile. */\n  type?: string\n  /** The exceptions for the tile. If the tile has a type, the exceptions can be defined by the type. */\n  exceptions?: Exceptions | string[]\n  /** The weight of the tile. Can also be 0, which effectively removes the tile from the generation. */\n  weight?: number\n}\n\ntype AlgorithmDefinition = {\n  options?: Options\n  tiles: TileDefinition[]\n}\n\nexport class WaveCollapse {\n  private definition: AlgorithmDefinition & { options: Options }\n  /** The tiles objects derived from their definitions. */\n  private tiles: Tile[]\n  /** The grid of cells. */\n  private grid: Cell[][] = [[]]\n  private _retryCount: number = 0\n\n  constructor(definition: AlgorithmDefinition) {\n    if (!definition.tiles || definition.tiles.length === 0) {\n      throw new Error('No tiles are defined.')\n    }\n    if (\n      definition.tiles.some((tile) => !tile.edges || tile.edges.length !== 4)\n    ) {\n      throw new Error('All tiles must have exactly 4 edges.')\n    }\n    if (\n      definition.tiles.some((tile) =>\n        tile.edges.some((edge) => edge.length === 0),\n      )\n    ) {\n      throw new Error('All edges must have a length of at least 1.')\n    }\n    if (\n      definition.options?.startCell?.cell === 'defined' &&\n      !definition.options.startCell.cellCoords\n    ) {\n      throw new Error(\n        \"The start cell is 'defined', but no coordinates are given.\",\n      )\n    }\n\n    this.definition = { options: {}, ...definition }\n    this.definition.options.defaultTileWeight ??= 10\n    this.definition.options.startCell ??= {\n      cell: 'random',\n      tileIndex: Math.floor(Math.random() * definition.tiles.length),\n    }\n    this.definition.options.maxRetryCount ??= 100\n    this.tiles = definition.tiles.map(\n      (_, index) =>\n        new Tile(\n          definition.tiles,\n          index,\n          this.definition.options.defaultTileWeight!,\n        ),\n    )\n  }\n\n  private _clear(): void {\n    // Clear the wave collapse data from any previous runs.\n    for (let y = 0; y < this.grid.length; y++) {\n      for (let x = 0; x < this.grid[0].length; x++) {\n        this.grid[y][x].clear()\n      }\n    }\n  }\n\n  private _initializeGrid(width: number, height: number): void {\n    this.grid = new Array<Cell[]>(height)\n    for (let y = 0; y < height; y++) {\n      const row = new Array<Cell>(width)\n      for (let x = 0; x < width; x++) {\n        row[x] = new Cell(x, y, this.tiles)\n      }\n      this.grid[y] = row\n    }\n  }\n\n  private _pickStartingCell(): Cell {\n    const { startCell } = this.definition.options\n    if (!startCell) {\n      throw new Error('No start cell is defined.')\n    }\n\n    let x: number, y: number\n    switch (startCell.cell) {\n      case 'middle':\n        x = Math.floor(this.grid[0].length / 2)\n        y = Math.floor(this.grid.length / 2)\n        break\n      case 'topLeft':\n        x = 0\n        y = 0\n        break\n      case 'topRight':\n        x = this.grid[0].length - 1\n        y = 0\n        break\n      case 'bottomLeft':\n        x = 0\n        y = this.grid.length - 1\n        break\n      case 'bottomRight':\n        x = this.grid[0].length - 1\n        y = this.grid.length - 1\n        break\n      case 'defined':\n        if (!startCell.cellCoords) {\n          throw new Error(\n            \"The start cell is 'defined', but no coordinates are given.\",\n          )\n        }\n        ;({ x, y } = startCell.cellCoords)\n        break\n      case 'random':\n      default:\n        x = Math.floor(Math.random() * this.grid[0].length)\n        y = Math.floor(Math.random() * this.grid.length)\n        break\n    }\n    this.grid[y][x].tileIndex = startCell.tileIndex\n    this.grid[y][x].updatePossibleTiles([startCell.tileIndex])\n    return this.grid[y][x]\n  }\n\n  generate(width: number, height: number): number[][] | null {\n    if (width <= 0 || height <= 0) {\n      return []\n    }\n    // Setup all necessary data structures for the algorithm.\n    this._initializeGrid(width, height)\n\n    this._retryCount = 0\n    while (this._retryCount < this.definition.options.maxRetryCount!) {\n      // Pick the starting cell. Since it has its possibilities reduced to one, it will be the first cell to collapse.\n      this._pickStartingCell()\n\n      // const waveHeap: Cell[] = []\n      const waveHeap = new PrioList<Cell>(\n        (a) => a.entropy,\n        // (a, b) => a.entropy - b.entropy || a.randomIndex - b.randomIndex,\n      )\n      for (const row of this.grid) {\n        for (const cell of row) {\n          waveHeap.push(cell)\n        }\n      }\n\n      // Continue collapsing cells until the grid is filled.\n      wave: while (!waveHeap.isEmpty()) {\n        // Pick next cell with lowest entropy and collapse it.\n        const cell = waveHeap.pop()!\n        cell.collapse()\n\n        // Heap for all the remaining propagations.\n        const propagationQueue: Cell[] = []\n        propagationQueue.push(cell)\n        while (propagationQueue.length > 0) {\n          const nextCell = propagationQueue.pop()!\n          // Update its neighbors and collect all updated neighbors in the propagation heap.\n          if (\n            !this._propagateToNeighbors(nextCell, waveHeap, propagationQueue)\n          ) {\n            break wave\n          }\n        }\n      }\n\n      // If the grid is filled, return the result.\n      if (waveHeap.isEmpty()) {\n        return this.grid.map((row) => row.map((cell) => cell.tileIndex!))\n      }\n      this._retryCount++\n      this._clear()\n    }\n\n    return null\n  }\n\n  private _propagateToNeighbors(\n    updatedCell: Cell,\n    waveHeap: PrioList<Cell>,\n    propagationQueue: Cell[],\n  ): boolean {\n    // Roll out the direction \"loop\" and avoid even optimized stuff like generators.\n    if (updatedCell.y > 0) {\n      const neighbor = this.grid[updatedCell.y - 1][updatedCell.x]\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          'possibleTilesUp',\n          waveHeap,\n          propagationQueue,\n        )\n      ) {\n        return false\n      }\n    }\n    if (updatedCell.x < this.grid[0].length - 1) {\n      const neighbor = this.grid[updatedCell.y][updatedCell.x + 1]\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          'possibleTilesRight',\n          waveHeap,\n          propagationQueue,\n        )\n      ) {\n        return false\n      }\n    }\n    if (updatedCell.y < this.grid.length - 1) {\n      const neighbor = this.grid[updatedCell.y + 1][updatedCell.x]\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          'possibleTilesDown',\n          waveHeap,\n          propagationQueue,\n        )\n      ) {\n        return false\n      }\n    }\n    if (updatedCell.x > 0) {\n      const neighbor = this.grid[updatedCell.y][updatedCell.x - 1]\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          'possibleTilesLeft',\n          waveHeap,\n          propagationQueue,\n        )\n      ) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Update the neighbor's possible tiles based on the updated cell.\n   *\n   * If any of the neighbor's possible tiles are updated, they will be added to the propagation queue.\n   *\n   * @returns `true` whether the neighbor was successfully updated or `false` if a contradiction was found.\n   */\n  private _propagate(\n    updatedCell: Cell,\n    neighbor: Cell,\n    possibleTilesDirection: keyof Tile,\n    waveHeap: PrioList<Cell>,\n    propagationQueue: Cell[],\n  ): boolean {\n    const possibleTiles: number[] = []\n    for (const tileIndex of updatedCell.possibleTiles) {\n      for (const possibleTile of this.tiles[tileIndex][\n        possibleTilesDirection\n      ] as number[]) {\n        if (\n          neighbor.possibleTiles.includes(possibleTile) &&\n          !possibleTiles.includes(possibleTile)\n        ) {\n          possibleTiles.push(possibleTile)\n        }\n      }\n    }\n\n    if (possibleTiles.length === 0) {\n      // Contradiction found\n      return false\n    }\n    if (possibleTiles.length !== neighbor.possibleTiles.length) {\n      const oldEntropy = neighbor.entropy\n      neighbor.updatePossibleTiles(possibleTiles)\n      waveHeap.refresh(neighbor, oldEntropy)\n      // don't check for inclusion because this will hit performance harder than checking twice\n      propagationQueue.push(neighbor)\n    }\n    return true\n  }\n}\n\nclass Tile {\n  /** The index of the tile within the tile definitions. */\n  public index: number\n  /** The compatibility edges of the tile. Only matching edges can be placed next to each other.\n   *\n   * A good notation is e.g. 'ABC' or 'AAA' describing how the edge \"looks like\". The order is \"top\", \"right\", \"bottom\", \"left\".\n   *\n   * Mind that when describing the edges when looking at a visual tileset top and bottomedges are written from left to right and left and right edges from top to bottom. */\n  public edges: [string, string, string, string]\n  /** The exceptions for the tile. If the tile has a type, the exceptions can be defined by the type. */\n  public exceptions?: Exceptions | string[]\n  /** A custom type given by the user of the tile (e.g., 'floor', 'wall'). This is used to define exceptions for the tile. */\n  public type?: string\n  /** The weight of the tile. Can also be 0, which effectively removes the tile from the generation. */\n  public weight: number\n  /** The weight of the tile multiplied by the logarithm of the weight. */\n  public weightLogWeight: number\n  /** The possible tiles (via index) that can be placed above this tile. */\n  public possibleTilesUp: number[]\n  /** The possible tiles (via index) that can be placed to the right of this tile. */\n  public possibleTilesRight: number[]\n  /** The possible tiles (via index) that can be placed below this tile. */\n  public possibleTilesDown: number[]\n  /** The possible tiles (via index) that can be placed to the left of this tile. */\n  public possibleTilesLeft: number[]\n\n  constructor(\n    tileDefinitions: TileDefinition[],\n    tileIndex: number,\n    defaultWeight: number = 10,\n  ) {\n    const definition = tileDefinitions[tileIndex]\n    this.index = tileIndex\n    this.edges = definition.edges\n    this.exceptions = definition.exceptions\n    this.weight = definition.weight ?? defaultWeight\n    this.weightLogWeight = this.weight\n      ? this.weight * Math.log2(this.weight)\n      : 0\n    this.type = definition.type\n\n    const checkExceptions = (\n      tile: Tile,\n      otherTile: TileDefinition,\n    ): boolean => {\n      const exceptions = tile.exceptions\n      if (!exceptions || !otherTile.type) {\n        return true\n      }\n      if (Array.isArray(exceptions)) {\n        return !exceptions.includes(otherTile.type)\n      }\n      if (exceptions.left && exceptions.left.includes(otherTile.type)) {\n        return false\n      }\n      if (exceptions.right && exceptions.right.includes(otherTile.type)) {\n        return false\n      }\n      if (exceptions.up && exceptions.up.includes(otherTile.type)) {\n        return false\n      }\n      if (exceptions.down && exceptions.down.includes(otherTile.type)) {\n        return false\n      }\n      return true\n    }\n\n    this.possibleTilesUp = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[0] === otherTile.edges[2] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null\n      })\n      .filter((index): index is number => index !== null)\n\n    this.possibleTilesRight = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[1] === otherTile.edges[3] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null\n      })\n      .filter((index): index is number => index !== null)\n\n    this.possibleTilesDown = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[2] === otherTile.edges[0] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null\n      })\n      .filter((index): index is number => index !== null)\n\n    this.possibleTilesLeft = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[3] === otherTile.edges[1] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null\n      })\n      .filter((index): index is number => index !== null)\n  }\n}\n\nclass Cell {\n  public x: number\n  public y: number\n  public randomIndex: number\n  /** The available tiles for the whole generation. */\n  public availableTiles: Tile[]\n  /** The possible tiles that can be placed in this cell. */\n  public possibleTiles: number[] = []\n  /** The index of the tile that was collapsed to this cell. */\n  public tileIndex: number | null = null\n  /** The Shannon entropy of the cell. See: https://robertheaton.com/2018/12/17/wavefunction-collapse-algorithm/ */\n  public entropy: number = 0\n  public listNode: ListNode<any> | undefined\n  private _sumOfWeights: number = 0\n  private _sumOfWeightLogWeights: number = 0\n\n  constructor(x: number, y: number, availableTiles: Tile[]) {\n    this.x = x\n    this.y = y\n    this.randomIndex = Math.floor(Math.random() * 0xffffffff)\n    this.availableTiles = availableTiles\n\n    this.clear()\n  }\n\n  clear(): void {\n    this.tileIndex = null\n    this.updatePossibleTiles(this.availableTiles.map((_, index) => index))\n  }\n\n  updatePossibleTiles(possibleTiles: number[]): void {\n    this.possibleTiles = possibleTiles\n    this._sumOfWeights = possibleTiles.reduce((sum, tileIndex) => {\n      return sum + this.availableTiles[tileIndex].weight\n    }, 0)\n    this._sumOfWeightLogWeights = possibleTiles.reduce((sum, tileIndex) => {\n      return sum + this.availableTiles[tileIndex].weightLogWeight\n    }, 0)\n    this.entropy = this._sumOfWeights\n      ? Math.log2(this._sumOfWeights) -\n        this._sumOfWeightLogWeights / this._sumOfWeights\n      : 0\n  }\n\n  collapse(): void {\n    if (this.possibleTiles.length === 0) {\n      throw new Error('No possible tiles to collapse to.')\n    }\n\n    // Selects tile based on weights randomly.\n    const weights = this.possibleTiles.map(\n      (tileIndex) => this.availableTiles[tileIndex].weight,\n    )\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0)\n\n    let randomWeight = Math.random() * totalWeight\n    for (let i = 0; i < weights.length; i++) {\n      randomWeight -= weights[i]\n      if (randomWeight <= 0) {\n        const chosenTile = this.possibleTiles[i]\n        this.tileIndex = chosenTile\n        this.possibleTiles = [chosenTile]\n        this.entropy = 0 // Entropy is zero since the cell is collapsed\n        return\n      }\n    }\n\n    throw new Error('No tile was chosen.')\n  }\n}\n","export class PrioList<T extends ListElement<T>> {\n  private head: ListNode<T> | undefined\n  private prios: number[] = []\n  private prioLookup: Map<number, ListNode<T>> = new Map()\n\n  constructor(private prioAccess: (a: T) => number) {}\n\n  push(item: T) {\n    const node = new ListNode(item)\n    item.listNode = node\n\n    this.insertNodeInPrios(node)\n    if (!this.head || this.head.prev == node) {\n      this.head = node\n    }\n  }\n\n  pop(): T | undefined {\n    if (!this.head) {\n      return undefined\n    }\n    const node = this.head\n    this.removeNodeFromPrios(node, this.prioAccess(node.value))\n    this.head = node.next\n\n    node.value.listNode = undefined\n    return node.value\n  }\n\n  refresh(item: T, oldPriority: number) {\n    if (!item.listNode) {\n      throw new Error('Item is not in the list')\n    }\n    if (this.prioAccess(item) == oldPriority) {\n      return\n    }\n\n    this.removeNodeFromPrios(item.listNode, oldPriority)\n    if (this.head == item.listNode) {\n      this.head = item.listNode.next\n    }\n    this.insertNodeInPrios(item.listNode)\n    if (!this.head || this.head.prev == item.listNode) {\n      this.head = item.listNode\n    }\n  }\n\n  isEmpty() {\n    return !this.head\n  }\n\n  private insertNodeInPrios(node: ListNode<T>) {\n    const prio = this.prioAccess(node.value)\n    let other: ListNode<T> | undefined\n    if ((other = this.prioLookup.get(prio))) {\n      // found the same prio, insert after and update prioLookup\n      if (other.next) other.next.prev = node\n      node.next = other.next\n      node.prev = other\n      other.next = node\n      this.prioLookup.set(prio, node)\n      return\n    }\n\n    // find the prio to insert before\n    let foundIdx: number | undefined\n    for (let [idx, other] of this.prios.entries()) {\n      if (other > prio) {\n        foundIdx = idx\n        break\n      }\n    }\n\n    if (foundIdx === undefined) {\n      // insert at the end\n      const last = this.prioLookup.get(this.prios[this.prios.length - 1])\n      if (last) {\n        last.next = node\n        node.prev = last\n      }\n      this.prios.push(prio)\n      this.prioLookup.set(prio, node)\n      return\n    }\n\n    // insert before the foundIdx\n    other = this.prioLookup.get(this.prios[foundIdx])!\n    if (other.prev) other.prev.next = node\n    node.prev = other.prev\n    node.next = other\n    other.prev = node\n    this.prios.splice(foundIdx, 0, prio)\n    this.prioLookup.set(prio, node)\n  }\n\n  private removeNodeFromPrios(node: ListNode<T>, prio: number) {\n    if (node.prev) node.prev.next = node.next\n    if (node.next) node.next.prev = node.prev\n\n    if (node !== this.prioLookup.get(prio)) {\n      return\n    }\n\n    if (!node.prev || this.prioAccess(node.prev.value) != prio) {\n      // last node with this prio\n      this.prioLookup.delete(prio)\n      this.prios.splice(this.prios.indexOf(prio), 1)\n      return\n    }\n\n    this.prioLookup.set(prio, node.prev)\n  }\n}\n\nexport class ListNode<T extends ListElement<T>> {\n  constructor(\n    public value: T,\n    public prev: ListNode<T> | undefined = undefined,\n    public next: ListNode<T> | undefined = undefined,\n  ) {}\n}\n\nexport type ListElement<T> = {\n  listNode: ListNode<any> | undefined\n}\n"],"mappings":"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","names":["other"]}