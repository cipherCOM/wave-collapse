{"version":3,"sources":["../src/wave-collapse.ts"],"sourcesContent":["type CellCoords = {\n  x: number;\n  y: number;\n};\n\ntype Direction = \"Up\" | \"Right\" | \"Down\" | \"Left\";\n\ntype StartPosition =\n  | \"random\"\n  | \"middle\"\n  | \"topLeft\"\n  | \"topRight\"\n  | \"bottomLeft\"\n  | \"bottomRight\"\n  | \"defined\";\n\ntype StartCell = {\n  cell: StartPosition;\n  cellCoords?: CellCoords;\n  tileIndex: number;\n};\n\ntype Options = {\n  defaultTileWeight?: number;\n  startCell?: StartCell;\n  maxRetryCount?: number;\n};\n\ntype Exceptions = {\n  left?: string[];\n  right?: string[];\n  down?: string[];\n  up?: string[];\n};\n\ntype TileDefinition = {\n  edges: [string, string, string, string];\n  type?: string;\n  exceptions?: Exceptions | string[];\n  weight?: number;\n};\n\ntype AlgorithmDefinition = {\n  options: Options;\n  tiles: TileDefinition[];\n};\n\nexport class WaveCollapse {\n  private definition: AlgorithmDefinition;\n  private tiles: Tile[];\n  private grid: Cell[][] = [[]];\n  private _retryCount: number = 0;\n\n  constructor(definition: AlgorithmDefinition) {\n    if (!definition.tiles || definition.tiles.length === 0) {\n      throw new Error(\"No tiles are defined.\");\n    }\n    if (\n      definition.tiles.some((tile) => !tile.edges || tile.edges.length !== 4)\n    ) {\n      throw new Error(\"All tiles must have exactly 4 edges.\");\n    }\n    if (\n      definition.tiles.some((tile) =>\n        tile.edges.some((edge) => edge.length === 0)\n      )\n    ) {\n      throw new Error(\"All edges must have a length of at least 1.\");\n    }\n    if (\n      definition.options?.startCell?.cell === \"defined\" &&\n      !definition.options.startCell.cellCoords\n    ) {\n      throw new Error(\n        \"The start cell is 'defined', but no coordinates are given.\"\n      );\n    }\n\n    this.definition = definition;\n    this.definition.options ??= {};\n    this.definition.options.defaultTileWeight ??= 10;\n    this.definition.options.startCell ??= {\n      cell: \"random\",\n      tileIndex: Math.floor(Math.random() * definition.tiles.length),\n    };\n    this.definition.options.maxRetryCount ??= 100;\n    this.tiles = definition.tiles.map(\n      (_, index) =>\n        new Tile(definition.tiles, index, definition.options.defaultTileWeight!)\n    );\n\n    this._clear();\n  }\n\n  private _clear(): void {\n    this.grid = [[]];\n    this._retryCount = 0;\n  }\n\n  private _initializeGrid(width: number, height: number): void {\n    this.grid = [];\n    for (let y = 0; y < height; y++) {\n      const row: Cell[] = [];\n      for (let x = 0; x < width; x++) {\n        row.push(new Cell(x, y, this.tiles));\n      }\n      this.grid.push(row);\n    }\n  }\n\n  private _pickStartingCell(): Cell {\n    const { startCell } = this.definition.options;\n    let x: number, y: number;\n    switch (startCell!.cell) {\n      case \"middle\":\n        x = Math.floor(this.grid[0].length / 2);\n        y = Math.floor(this.grid.length / 2);\n        break;\n      case \"topLeft\":\n        x = 0;\n        y = 0;\n        break;\n      case \"topRight\":\n        x = this.grid[0].length - 1;\n        y = 0;\n        break;\n      case \"bottomLeft\":\n        x = 0;\n        y = this.grid.length - 1;\n        break;\n      case \"bottomRight\":\n        x = this.grid[0].length - 1;\n        y = this.grid.length - 1;\n        break;\n      case \"defined\":\n        if (!startCell!.cellCoords) {\n          throw new Error(\n            \"The start cell is 'defined', but no coordinates are given.\"\n          );\n        }\n        ({ x, y } = startCell!.cellCoords);\n        break;\n      case \"random\":\n      default:\n        x = Math.floor(Math.random() * this.grid[0].length);\n        y = Math.floor(Math.random() * this.grid.length);\n        break;\n    }\n    this.grid[y][x].tileIndex = startCell!.tileIndex;\n    this.grid[y][x].updatePossibleTiles([startCell!.tileIndex]);\n    return this.grid[y][x];\n  }\n\n  generate(width: number, height: number): number[][] | null {\n    if (width <= 0 || height <= 0) {\n      return [];\n    }\n    this._clear();\n\n    while (this._retryCount < this.definition.options.maxRetryCount!) {\n      this._initializeGrid(width, height);\n      this._pickStartingCell();\n\n      const waveHeap: Cell[] = [];\n      for (const row of this.grid) {\n        for (const cell of row) {\n          waveHeap.push(cell);\n        }\n      }\n      waveHeap.sort(\n        (a, b) => a.entropy - b.entropy || a.randomIndex - b.randomIndex\n      );\n\n      wave: while (waveHeap.length > 0) {\n        const cell = waveHeap.shift()!;\n        cell.collapse();\n\n        const propagationQueue: Cell[] = [];\n        propagationQueue.push(cell);\n        while (propagationQueue.length > 0) {\n          const nextCell = propagationQueue.pop()!;\n          if (\n            !this._propagateToNeighbors(nextCell, waveHeap, propagationQueue)\n          ) {\n            break wave;\n          }\n        }\n      }\n\n      if (waveHeap.length === 0) {\n        return this.grid.map((row) => row.map((cell) => cell.tileIndex!));\n      }\n      this._retryCount++;\n    }\n\n    return null;\n  }\n\n  private _propagateToNeighbors(\n    updatedCell: Cell,\n    waveHeap: Cell[],\n    propagationQueue: Cell[]\n  ): boolean {\n    if (updatedCell.y > 0) {\n      const neighbor = this.grid[updatedCell.y - 1][updatedCell.x];\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          \"possibleTilesUp\",\n          waveHeap,\n          propagationQueue\n        )\n      ) {\n        return false;\n      }\n    }\n    if (updatedCell.x < this.grid[0].length - 1) {\n      const neighbor = this.grid[updatedCell.y][updatedCell.x + 1];\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          \"possibleTilesRight\",\n          waveHeap,\n          propagationQueue\n        )\n      ) {\n        return false;\n      }\n    }\n    if (updatedCell.y < this.grid.length - 1) {\n      const neighbor = this.grid[updatedCell.y + 1][updatedCell.x];\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          \"possibleTilesDown\",\n          waveHeap,\n          propagationQueue\n        )\n      ) {\n        return false;\n      }\n    }\n    if (updatedCell.x > 0) {\n      const neighbor = this.grid[updatedCell.y][updatedCell.x - 1];\n      if (\n        !this._propagate(\n          updatedCell,\n          neighbor,\n          \"possibleTilesLeft\",\n          waveHeap,\n          propagationQueue\n        )\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _propagate(\n    updatedCell: Cell,\n    neighbor: Cell,\n    possibleTilesDirection: keyof Tile,\n    waveHeap: Cell[],\n    propagationQueue: Cell[]\n  ): boolean {\n    const possibleTiles: number[] = [];\n    for (const tileIndex of updatedCell.possibleTiles) {\n      for (const possibleTile of this.tiles[tileIndex][\n        possibleTilesDirection\n      ] as number[]) {\n        if (\n          neighbor.possibleTiles.includes(possibleTile) &&\n          !possibleTiles.includes(possibleTile)\n        ) {\n          possibleTiles.push(possibleTile);\n        }\n      }\n    }\n\n    if (possibleTiles.length === 0) {\n      return false;\n    }\n    if (possibleTiles.length !== neighbor.possibleTiles.length) {\n      const oldEntropy = neighbor.entropy;\n      neighbor.updatePossibleTiles(possibleTiles);\n      if (neighbor.entropy !== oldEntropy) {\n        const index = waveHeap.indexOf(neighbor);\n        waveHeap.splice(index, 1);\n\n        let newIndex = waveHeap.findIndex(\n          (other) =>\n            neighbor.entropy < other.entropy ||\n            (neighbor.entropy === other.entropy &&\n              neighbor.randomIndex < other.randomIndex)\n        );\n        if (newIndex === -1) {\n          newIndex = waveHeap.length;\n        }\n        waveHeap.splice(newIndex, 0, neighbor);\n      }\n      if (!propagationQueue.includes(neighbor)) {\n        propagationQueue.push(neighbor);\n      }\n    }\n    return true;\n  }\n}\n\nclass Tile {\n  public index: number;\n  public edges: [string, string, string, string];\n  public exceptions?: Exceptions | string[];\n  public weight: number;\n  public weightLogWeight: number;\n  public type?: string;\n  public possibleTilesUp: number[];\n  public possibleTilesRight: number[];\n  public possibleTilesDown: number[];\n  public possibleTilesLeft: number[];\n\n  constructor(\n    tileDefinitions: TileDefinition[],\n    tileIndex: number,\n    defaultWeight: number = 10\n  ) {\n    const definition = tileDefinitions[tileIndex];\n    this.index = tileIndex;\n    this.edges = definition.edges;\n    this.exceptions = definition.exceptions;\n    this.weight = definition.weight ?? defaultWeight;\n    this.weightLogWeight = this.weight\n      ? this.weight * Math.log2(this.weight)\n      : 0;\n    this.type = definition.type;\n\n    const checkExceptions = (\n      tile: Tile,\n      otherTile: TileDefinition\n    ): boolean => {\n      const exceptions = tile.exceptions;\n      if (!exceptions) {\n        return true;\n      }\n      if (Array.isArray(exceptions)) {\n        return !exceptions.includes(otherTile.type!);\n      }\n      if (exceptions.left && exceptions.left.includes(otherTile.type!)) {\n        return false;\n      }\n      if (exceptions.right && exceptions.right.includes(otherTile.type!)) {\n        return false;\n      }\n      if (exceptions.up && exceptions.up.includes(otherTile.type!)) {\n        return false;\n      }\n      if (exceptions.down && exceptions.down.includes(otherTile.type!)) {\n        return false;\n      }\n      return true;\n    };\n\n    this.possibleTilesUp = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[0] === otherTile.edges[2] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null;\n      })\n      .filter((index): index is number => index !== null);\n\n    this.possibleTilesRight = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[1] === otherTile.edges[3] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null;\n      })\n      .filter((index): index is number => index !== null);\n\n    this.possibleTilesDown = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[2] === otherTile.edges[0] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null;\n      })\n      .filter((index): index is number => index !== null);\n\n    this.possibleTilesLeft = tileDefinitions\n      .map((otherTile, otherIndex) => {\n        return this.edges[3] === otherTile.edges[1] &&\n          checkExceptions(this, otherTile)\n          ? otherIndex\n          : null;\n      })\n      .filter((index): index is number => index !== null);\n  }\n}\n\nclass Cell {\n  public x: number;\n  public y: number;\n  public randomIndex: number;\n  public availableTiles: Tile[];\n  public possibleTiles: number[] = [];\n  public tileIndex: number | null;\n  public entropy: number = 0;\n  private _sumOfWeights: number = 0;\n  private _sumOfWeightLogWeights: number = 0;\n\n  constructor(x: number, y: number, availableTiles: Tile[]) {\n    this.x = x;\n    this.y = y;\n    this.randomIndex = Math.floor(Math.random() * 0xffffffff);\n    this.availableTiles = availableTiles;\n\n    this.tileIndex = null;\n    this.updatePossibleTiles(availableTiles.map((_, index) => index));\n  }\n\n  updatePossibleTiles(possibleTiles: number[]): void {\n    this.possibleTiles = possibleTiles;\n    this._sumOfWeights = possibleTiles.reduce((sum, tileIndex) => {\n      return sum + this.availableTiles[tileIndex].weight;\n    }, 0);\n    this._sumOfWeightLogWeights = possibleTiles.reduce((sum, tileIndex) => {\n      return sum + this.availableTiles[tileIndex].weightLogWeight;\n    }, 0);\n    this.entropy = this._sumOfWeights\n      ? Math.log2(this._sumOfWeights) -\n        this._sumOfWeightLogWeights / this._sumOfWeights\n      : 0;\n  }\n\n  collapse(): void {\n    if (this.possibleTiles.length === 0) {\n      throw new Error(\"No possible tiles to collapse to.\");\n    }\n\n    const weights = this.possibleTiles.map(\n      (tileIndex) => this.availableTiles[tileIndex].weight\n    );\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\n\n    let randomWeight = Math.random() * totalWeight;\n    for (let i = 0; i < weights.length; i++) {\n      randomWeight -= weights[i];\n      if (randomWeight <= 0) {\n        const chosenTile = this.possibleTiles[i];\n        this.tileIndex = chosenTile;\n        this.possibleTiles = [chosenTile];\n        this.entropy = 0;\n        return;\n      }\n    }\n\n    throw new Error(\"No tile was chosen.\");\n  }\n}\n"],"mappings":"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","names":[]}